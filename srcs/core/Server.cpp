#include "../../incs/classes/Server.hpp"

// === OTHER CLASSES ===
#include "../../incs/classes/Client.hpp"
#include "../../incs/classes/Channel.hpp"
#include "../../incs/classes/CommandHandler.hpp"
#include "../../incs/classes/CommandHandler_File.hpp"
#include "../../incs/classes/Utils.hpp"
#include "../../incs/classes/IrcHelper.hpp"
#include "../../incs/classes/MessageHandler.hpp"

// === NAMESPACES ===
#include "../../incs/config/irc_config.hpp"
#include "../../incs/config/colors.hpp"
#include "../../incs/config/server_messages.hpp"

using namespace server_messages;
using namespace colors;

// =========================================================================================
/**************************************** PUBLIC ****************************************/

// === SIGNAL ===

/**
 * @brief A static volatile variable to store the signal received status.
 * 
 * This variable is used to indicate whether a signal has been received.
 * It is declared as volatile to prevent the compiler from optimizing
 * out accesses to it, as it may be modified asynchronously by a signal
 * handler.
 */
volatile sig_atomic_t Server::signalReceived = boolean::FALSE;

/**
 * @brief Signal handler for the server.
 *
 * This function handles the SIGINT and SIGTSTP signals, which are typically
 * generated by pressing Ctrl+C or Ctrl+Z, respectively. When these signals are
 * caught, the server sets signalReceived to true to clean and terminate the program.
 *
 * @param signal The signal number that was caught.
 *
 * @return void
 */
void Server::signalHandler(int signal)
{
	const char* signalType;

	switch (signal)
	{
		case SIGINT: signalType = "SIGINT"; break;
		case SIGTSTP: signalType = "SIGTSTP"; break;
		default: signalType = "Unknown";
	}

	std::cout << MessageHandler::msgSignalCaught(signalType) << std::endl;
	signalReceived = boolean::TRUE;
}

sig_atomic_t Server::isSignalReceived() const
{
	return signalReceived;
}


// === CONSTUCTORS / DESTRUCTORS ===

/**
 * @brief Constructor for the Server class.
 *
 * Initializes the server with the given port and password.
 * Sets the server socket file descriptor and maximum file descriptor to -1 and 0, respectively.
 *
 * @param port The port number for the server to listen on. It must be a valid port number (0-65535).
 * @param password The password required for clients to connect to the server. It must be a non-empty string.
 *
 * @throws std::invalid_argument If the port number is not within the valid range or if the password is invalid or empty.
*/
Server::Server(const std::string &port, const std::string &password)
	: _serverSocketFd(-1), _maxFd(0), _files()
{
	_port = IrcHelper::validatePort(port);

	if (!IrcHelper::isValidPassword(password, true))
		throw std::invalid_argument(ERR_INVALID_PASSWORD);
	_password = password;

	_init();
}

/**
 * @brief Destructor for the Server class.
 *
 * Closes all client objects and connections, and closes the server socket.
 */
Server::~Server()
{
	_clean();
}


// === LAUNCH SERVER ===

/**
 * @brief Launches the IRC server.
 *
 * This function starts the IRC server by calling the start() function.
 * It catches any exceptions thrown by the start() function and prints an error message.
 *
 * @return void
 */
void Server::launch()
{

	try {
		_start();
	} catch (const std::exception &e) {
		std::cerr << MessageHandler::msgServerException(e) << std::endl;
	}
}

/**
 * @brief Cleanly exits the server.
 *
 * This function prints a message indicating that the server is exiting,
 * performs necessary cleanup operations by calling the _clean() method,
 * and then terminates the program with an exit status of 0.
 */
void Server::cleanExit()
{
	std::cout << "Exiting server..." << std::endl;
	_clean();
	exit(0);
}


/********** PUBLIC GETTERS AND METHODS FOR COMMANDHANDLER ACCESS **********/

// === SERVER INFOS ===

/**
 * @brief Retrieves the file descriptor for the server socket.
 * 
 * This function returns the file descriptor associated with the server socket,
 * which is used for network communication.
 * 
 * @return int The file descriptor of the server socket.
 */
int Server::getServerSocketFd() const
{
	return _serverSocketFd;
}

/**
 * @brief Retrieves the local IP address of the server.
 * 
 * This function returns a constant reference to the local IP address
 * stored in the server instance.
 * 
 * @return const std::string& A constant reference to the local IP address.
 */
const std::string& Server::getLocalIP() const
{
	return _localIp;
}

/**
 * @brief Retrieves the port number the server is using.
 * 
 * @return int The port number.
 */
int Server::getPort() const
{
	return _port;
}

/**
 * @brief Retrieves the set of file descriptors for reading.
 * 
 * This function returns a copy of the file descriptor set that is monitored
 * for read events. It can be used to check which file descriptors are ready
 * for reading.
 * 
 * @return fd_set The set of file descriptors for reading.
 */
fd_set Server::getReadFds() const
{
	return _readFds;
}

/**
 * @brief Get the maximum file descriptor currently in use by the server.
 *
 * This function checks the highest file descriptor among the connected clients
 * and updates the server's maximum file descriptor (_maxFd) if a higher value
 * is found. It then returns the maximum file descriptor.
 *
 * @return int The maximum file descriptor currently in use by the server.
 */
int Server::getMaxFd()
{
	if (!_clients.empty())
	{
		int maxClientFd = _clients.rbegin()->first;
		if (maxClientFd > _maxFd)
			return maxClientFd;
	}
	return _serverSocketFd;
}

/**
 * @brief Returns the server's password.
 *
 * This function returns the server's password as a constant reference to a string.
 *
 * @return const std::string& The server's password.
 */
const std::string& Server::getServerPassword() const
{
	return _password;
}


// === CLIENTS ===

/**
 * @brief Returns the list of clients.
 *
 * This function returns the list of clients as a reference.
 *
 * @return std::map<int, Client*>& The list of clients.
 */
std::map<int, Client*>& Server::getClients()
{
	return _clients;
}

/**
 * @brief Get the number of clients connected to the server.
 * 
 * @return int The number of clients.
 */
int Server::getTotalClientCount() const
{
	return _clients.size();
}

/**
 * @brief Get the count of clients based on their authentication status.
 * 
 * @param authenticated If true, count only authenticated clients; 
 *                      if false, count only unauthenticated clients.
 * @return int The number of clients that match the specified authentication status.
 */
int Server::getClientCount(bool authenticated)
{
	int count = 0;
	for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it)
	{
		if (authenticated && (it->second)->isAuthenticated())
			count++;
		else if (!authenticated && !(it->second)->isAuthenticated())
			count++;
	}
	return count;
}

/**
 * @brief Retrieves the client ID associated with a given nickname.
 *
 * This function iterates through the list of clients and returns the ID of the client
 * whose nickname matches the provided nickname. If the optional currClient parameter
 * is provided, it will be skipped during the search.
 *
 * @param nickname The nickname of the client to search for.
 * @param currClient Optional parameter to specify a client to be skipped during the search.
 * @return The ID of the client with the matching nickname, or -1 if no match is found.
 */
int Server::getClientByNickname(const std::string &nickname, Client* currClient)
{
	for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); it++)
	{
		if (currClient && currClient == it->second)
			continue;
		if (nickname == (it->second)->getNickname()) 
			return it->first;
	}
	return -1;
}

/**
 * @brief Sends a greeting message to a newly connected client.
 *
 * This function sends a series of welcome messages to the client, including:
 * - A welcome message with the client's username, nickname, and IP address.
 * - Host information.
 * - Server creation time.
 * - Additional server information.
 * - A global user list with the total number of clients, known clients, unknown clients, and channels.
 *
 * @param client A pointer to the Client object representing the newly connected client.
 */
void Server::greetClient(Client* client)
{
	const std::string& nickname = client->getNickname();
	const std::string& usermask = client->getUsermask();

	client->sendMessage(MessageHandler::ircWelcomeMessage(nickname, usermask), NULL);
	client->sendMessage(MessageHandler::ircHostInfos(nickname), NULL);
	client->sendMessage(MessageHandler::ircTimeCreation(nickname, _timeCreationStr), NULL);
	client->sendMessage(MessageHandler::ircInfos(nickname), NULL);
	client->sendMessage(MessageHandler::ircMOTDMessage(nickname), NULL);

	int totalClientCount = getTotalClientCount();
	int unknownClientCount = getClientCount(false);
	int knownClientCount = getClientCount(true);
	int channelCount = getChannelCount();

	client->sendMessage(MessageHandler::ircGlobalUserList(nickname, totalClientCount, knownClientCount, unknownClientCount, channelCount), NULL);
}

/**
 * @brief Prepares a client to leave the server.
 *
 * This function handles the necessary steps to properly disconnect a client from the server.
 * It ensures that the client leaves all channels they are part of, disconnects the client,
 * and marks the client for deletion.
 *
 * @param it An iterator pointing to the client in the map of clients.
 */
void Server::prepareClientToLeave(std::map<int, Client*>::iterator it, const std::string& reason)
{
	int clientFd = it->first;
	Client* client = it->second;

	client->leaveAllChannels(_channels, reason, leaving_code::QUIT_SERV);
	_disconnectClient(clientFd, reason);
	_clientsToDelete.push_back(it);
}


// === CHANNELS ===

/**
 * @brief Returns the list of channels.
 *
 * This function returns the list of channels as a reference to a map of channel names to Channel pointers.
 *
 * @return std::map<std::string, Channel*>& The list of channels.
 */
std::map<std::string, Channel*>& Server::getChannels()
{
	return _channels;
}

/**
 * @brief Get the number of channels in the server.
 * 
 * This function returns the total count of channels currently managed by the server.
 * 
 * @return int The number of channels.
 */
int Server::getChannelCount() const
{
	return _channels.size();
}

/**
 * @brief Broadcasts a message for nickname change to all connected and authenticated clients except those marked for deletion.
 * 
 * This function iterates through the list of connected clients and sends the specified
 * message to each client that is not present in the list of clients to be deleted.
 * 
 * @param message The message to be broadcasted to all connected and authenticated clients.
 */
void Server::broadcastToClients(const std::string &message)
{
	for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it)
	{
		std::vector<std::map<int, Client*>::iterator>::iterator itDeleted = std::find(_clientsToDelete.begin(), _clientsToDelete.end(), it);
		if (itDeleted == _clientsToDelete.end() && it->second->isAuthenticated())
			it->second->sendMessage(message, NULL);
	}
}


// === SEND FILE (BONUS) ===

/**
 * @brief Retrieves the map of files stored in the server.
 * 
 * This function returns a reference to the map that contains all the files
 * managed by the server. The map uses the file name as the key and the 
 * corresponding File object as the value.
 * 
 * @return std::map<std::string, File>& Reference to the map of files.
 */
std::map<std::string, File>& Server::getFiles()
{
	return (_files);
}

/**************************************** PRIVATE ****************************************/

Server::Server() {}
Server::Server(const Server& src) {(void) src;}
Server & Server::operator=(const Server& src) {(void) src; return *this;}


// === INIT / CLEAN ===

/**
 * @brief Sets the signal handler for SIGINT and SIGTSTP signals.
 *
 * This function sets the signal handler for SIGINT and SIGTSTP signals to the `signalHandler` function.
 * The signal handler function is responsible for handling the termination of the server gracefully.
 *
 * @return void
 *
 * @throws std::runtime_error If an error occurs while setting the signal handler.
 *
 * @see signalHandler
 */
void Server::_setSignal()
{
	struct sigaction sa;
	sa.sa_handler = &Server::signalHandler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	if (sigaction(SIGINT, &sa, NULL) == -1 || sigaction(SIGTSTP, &sa, NULL) == -1)
		throw std::runtime_error(ERR_SET_SIGNAL);
}

/**
 * @brief Configures the local IP address for the server to allow clients to connect from other machines.
 * 
 * This function retrieves the list of available network interfaces and sets the server's local IP address
 * to the first valid IPv4 address found, excluding the loopback address (127.0.0.1). If no valid address
 * is found, it defaults to the loopback address. If no network interfaces are available, it throws a runtime error.
 * 
 * @throws std::runtime_error If no valid network interface is found.
 */
void Server::_setLocalIp() // Configure l'adresse réseau pour permettre aux clients de se connecter depuis d'autres machines
{
	// Déclare un pointeur vers une structure contenant les adresses des interfaces réseau
	struct ifaddrs *networkInterfaces, *currInterface;

	// Récupère la liste des interfaces réseau disponibles
	// En cas d'échec, on utilise l'adresse locale par défaut (127.0.0.1)
	if (getifaddrs(&networkInterfaces) == -1)
	{
		_localIp = server::LOCALHOST;
		return;
	}

	// Parcourir la liste des interfaces réseau obtenues
	for (currInterface = networkInterfaces; currInterface; currInterface = currInterface->ifa_next) {

		// Vérifie si l'interface possède une adresse assignée et si c'est une adresse IPv4 (AF_INET)
		if (!currInterface->ifa_addr || currInterface->ifa_addr->sa_family != AF_INET)
			continue;

		// Convertit l'adresse IPv4 en chaîne de caractères lisible
		struct sockaddr_in* addr = (struct sockaddr_in*)currInterface->ifa_addr;
		char ipAddr[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &addr->sin_addr, ipAddr, sizeof(ipAddr));

		// Ignore 127.0.0.1 pour ne garder que les adresses réseau réelles
		if (std::string(ipAddr) != server::LOCALHOST)
		{
			_localIp = ipAddr; // Stocke la première adresse IP valide trouvée
			break;
		}
	}

	// Libère la mémoire allouée pour la liste des interfaces réseau
	freeifaddrs(networkInterfaces);

	if (_localIp.empty())
		throw std::runtime_error(ERR_NO_NETWORK);
}

/**
 * @brief Sets up the server socket, binds it to an address and port, and listens for incoming connections.
 *
 * This function creates a server socket, sets it to non-blocking mode, and binds it to a specific address and port.
 * It also listens for incoming connections and initializes the necessary variables for the server to function properly.
 *
 * @return void
 *
 * @throws std::runtime_error If any error occurs during the setup of the server socket.
 */
void Server::_setServerSocket()
{
	// Création du socket serveur (socket TCP)
	_serverSocketFd = socket(AF_INET, SOCK_STREAM, 0);
	if (_serverSocketFd < 0)
		throw std::runtime_error(ERR_SOCKET_CREATION);

	// Réutilisation de l'adresse et du port :
	// Après un arrêt brutal du serveur, si ce dernier n'a pas libéré immédiatement le port, 
	// SO_REUSEADDR permet de réutiliser le port pour se connecter sans attendre le délai habituel.
	int opt = 1;
	if (setsockopt(_serverSocketFd, SOCK_STREAM, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
		throw std::runtime_error(ERR_SET_SOCKET);

	// Rendre le socket non-bloquant avec O_NONBLOCK :
	// Le serveur doit être capable de gérer plusieurs connexions simultanées sans forking (interdit ici).
	// Il doit donc être non-bloquant (ne pas se bloquer tant qu'il n'a pas de nouvelles connexions, traité de message etc...)
	// On pourra donc traiter tous nos clients en continu dans une boucle sans interruption -> voir dans start()
	if (fcntl(_serverSocketFd, F_SETFL, O_NONBLOCK) < 0)
		throw std::runtime_error(ERR_SET_SERVER_NON_BLOCKING);

	// Définition de l'adresse du serveur
	// -> adresse IPv4 + port du serveur
	struct sockaddr_in serverAddr;
	std::memset(&serverAddr, 0, sizeof(serverAddr));  // Initialisation à 0 de la structure
	serverAddr.sin_family = AF_INET; // Type d'adresse (IPv4)
	serverAddr.sin_addr.s_addr = INADDR_ANY; // Accepte toutes les adresses IP locales
	serverAddr.sin_port = htons(_port); // Port sur lequel écouter (converti en format réseau)

	// Associer l'adresse définie au socket
	if (bind(_serverSocketFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0)
		throw std::runtime_error(ERR_BIND_SOCKET);

	// Ecouter les connexions entrantes
	// -> FD_SETSIZE spécifie le nombre max de connexions simultanées autorisées par select() (ici 1024)
	if (listen(_serverSocketFd, FD_SETSIZE) < 0)
		throw std::runtime_error(ERR_LISTEN_SOCKET);

	// _readFds = ensemble de descripteurs à surveiller pour les connexions/déconnexions, lecture/envoi de messages...
	// Sera mis à jour via une copie temporaire dans la boucle infinie de start()
	// FD_ZERO initialise _readFds à zéro pour s'assurer qu'il est vide avant d'y ajouter de nouveaux descripteurs
	FD_ZERO(&_readFds);

	// Ajout du socket du serveur (_serverSocketFd) à l'ensemble de descripteurs (_readFds)
	// pour écouter les connexions entrantes
	// NB: Nous n'ajoutons pas le serveur à l'ensemble de descripteurs pour l'écriture (_writeFds)
	FD_SET(_serverSocketFd, &_readFds); // Ajouter le socket serveur à l'ensemble

	// Le serveur peut maintenant accepter les connexions entrantes via select()
}

/**
 * @brief Initializes the server by setting up signals, local IP, server socket,
 *        writing environment file, and displaying welcome message.
 * 
 * This function performs the following steps:
 * - Sets up signal handling.
 * - Determines and sets the local IP address.
 * - Configures and sets up the server socket.
 * - Generates the server creation time string.
 * - Writes the environment file with the local IP and port.
 * - Displays a welcome message with the local IP, port, and password.
 */
void Server::_init()
{
	_setSignal();
	_setLocalIp();
	_setServerSocket();

	_timeCreationStr = MessageHandler::msgTimeServerCreation();
	IrcHelper::writeEnvFile(_localIp, _port, _password);
	MessageHandler::displayWelcome(_localIp, _port, _password);
}

/**
 * @brief Checks the activity of all connected clients and handles inactivity.
 *
 * This function iterates through all connected clients and performs the following actions:
 * - If a client has been inactive for more than 4 minutes, it sends a PING message to the client to check the connection.
 * - If a client has been inactive for more than 5 minutes (no PONG or command received), it prepares the client to be disconnected due to a connection timeout.
 */
void Server::_checkActivity()
{
	for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it)
	{
		Client* client = it->second;
		time_t idleTime = client->getIdleTime();

		// Au bout de 4 minutes d'inactivité, envoie un PING au client pour vérifier sa connexion
		if (!client->pingSent() && idleTime > server::PING_INTERVAL)
		{
			client->setPingSent(true);
			client->sendMessage(MessageHandler::ircPing(), NULL);
		}
		// Si le client est inactif depuis 5 minutes (pas de PONG ou de commande reçue), on le déconnecte
		if (idleTime > server::PONG_TIMEOUT)
			prepareClientToLeave(it, CONNECTION_TIMEOUT);
	}
}

/**
 * @brief Starts the IRC server.
 *
 * This function initializes the server socket, listens for incoming client connections,
 * and handles client messages using the select() system call. It also manages client deletion
 * and handles exceptions.
 *
 * @return void
 *
 * @throws std::exception If an error occurs during server initialization or execution.
 */
void Server::_start()
{
	// Boucle infinie pour écouter les connexions des clients tant que le serveur n'est pas interrompu
	while (1)
	{
		if (signalReceived)
			break;

		// Copie temporaire de l'ensemble des descripteurs à surveiller pour la lecture (_readFds) pour select()
		// qu'on réactualise à chaque itération de la boucle pour prendre en compte
		// les nouvelles connexions / déconnexions
		fd_set readFds = _readFds;

		// Récupérer le descripteur maximum pour select()
		// -> Si pas de client, ce sera le descripteur du serveur
		// -> Sinon, ce sera le descripteur du client avec le plus grand descripteur
		// 	qui se trouve a la fin de la map car celle-ci est automatiquement triée par ordre croissant
		_maxFd = getMaxFd();

		// Délai pour la fonction select: intervalle de 500 ms pour le retour de fonction
		struct timeval timeout = {0, 500000};

		// Attendre que l'un des descripteurs soit prêt pour la lecture ou l'écriture
		if (select(_maxFd + 1, &readFds, NULL, NULL, &timeout) < 0 && errno != EINTR)
			throw std::runtime_error(ERR_SELECT_SOCKET);

		// Envoi d'un PING à tous les clients inactifs pour vérifier leur connexion
		_checkActivity();

		// On parcourt tous les fds actifs.
		// Si le fd est le fd du serveur : autre fd tente de se connecter,
		// on accepte la nouvelle connexion et on cree un nouveau client.
		// Sinon, le fd est deja client, donc on traite son message.
		for (int fd = 0; fd <= _maxFd; fd++)
		{
			if (signalReceived)
				break;
			if (FD_ISSET(fd, &readFds))
			{
				if (fd == _serverSocketFd)
					_acceptNewClient();
				else
				{
					// On retrouve l'iterateur du client correspondant au fd dans la map _clients
					std::map<int, Client*>::iterator it = _clients.find(fd);
					_handleMessage(it);
				}

			}
		}

		// Supprimer les clients en attente de suppression
		// (les supprimer au fur et à mesure dans la boucle ci-dessus impliquerait
		// de modifier le conteneur pendant l'itération, ce qui causerait un comportement indéfini)
		_lateClientDeletion();
	}
}

/**
 * @brief cleans the IRC server and closes all connections.
 *
 * This function closes all client objects and connections, frees memory,
 * and closes the server socket. It also ensures that all open file descriptors
 * are properly closed.
 * Called in server destructor and signal handler.
 * 
 * @return void
 */
void Server::_clean()
{
	// Fermer toutes connexions clients + objets clients + channels
	while (!_clients.empty())
	{
		int clientFd = _clients.begin()->first;
		Client* client = _clients.begin()->second;

		client->leaveAllChannels(_channels, SHUTDOWN_REASON, leaving_code::QUIT_SERV);
		_disconnectClient(clientFd, SHUTDOWN_REASON);
		_deleteClient(_clients.begin());
	}

	// Fermer le socket du serveur
	if (close(_serverSocketFd) == -1)
	{
		perror("Failed to close server socket");
		return;
	}

	FD_ZERO(&_readFds);
	std::cout << MessageHandler::msgBuilder(COLOR_SUCCESS, SERVER_SHUT_DOWN, eol::UNIX) << std::endl;
}

// === MESSAGES / COMMANDS ===

/**
 * @brief Handles incoming messages from a specific client.
 *
 * This function receives messages from a client, processes them, and performs
 * necessary actions based on the received commands. It also manages client deletion
 * and handles exceptions.
 *
 * @param it An iterator pointing to the client in the map of connected clients.
 *
 * @return void
 *
 * @throws std::exception If an error occurs while processing the client's message.
 */
void Server::_handleMessage(std::map<int, Client*>::iterator it)
{
	int clientFd = it->first;
	Client* client = it->second;
	client->setLastActivity();

	char currentBuffer[server::BUFFER_SIZE];
	std::memset(currentBuffer, 0, sizeof(currentBuffer));
	ssize_t bytesRead = recv(clientFd, currentBuffer, sizeof(currentBuffer) - 1, 0);

	if (bytesRead < 0)
	{
		// Erreur de lecture
		perror("Failed to read from client");
		return;
	}
	if (bytesRead == 0)
	{
		// Client déconnecté proprement
		prepareClientToLeave(it, CLIENT_CLOSED_CONNECTION);
		return;
	}
	currentBuffer[bytesRead] = '\0';

	// On récupère le message stocké dans le buffer du client
	std::string& bufferMessage = client->getBufferMessage();

	// Ajoute les nouvelles données reçues au buffer existant
	bufferMessage.append(currentBuffer);

	// On parcourt les messages tant qu'il y a un \n
	size_t pos;
	while (((pos = bufferMessage.find('\n')) != std::string::npos))
	{
		// On extrait le message jusqu'au \n (non inclus)
		// + on enlève le \r s'il y en a un (cas irssi)
		// + on supprime la commande traitée du buffer
		std::string message = IrcHelper::extractAndCleanMessage(bufferMessage, pos);

		// Debug : affiche le message reçu
		// std::cout << "---> " << message << std::endl;

		// On traite le message extrait,
		// le reste sera traité à la prochaine itération
		_processCommand(it, message);
	}

	// S'il reste un message dans le buffer c'est because CTRL+D
	// On l'a déjà stocké dans le buffer, ça sera traité la fois suivante
	if (!bufferMessage.empty() && bufferMessage.size() < server::BUFFER_SIZE - 1)
		client->sendMessage("^D", NULL);
}

/**
 * @brief Processes the input message from a client.
 *
 * This function takes an iterator to a map of clients and a message string,
 * and processes the input message from the client associated with the iterator.
 * It creates a CommandHandler object to manage the command contained in the message.
 * If an exception is thrown during command management, the exception message is sent
 * back to the client.
 *
 * @param it Iterator to a map of clients, where the key is an integer and the value is a pointer to a Client object.
 * @param message The input message from the client to be processed.
 */
void Server::_processCommand(std::map<int, Client*>::iterator it, std::string message)
{
	Client* client = it->second;
	if (client->errorMsgTooLongSent() == true)
		client->setErrorMsgTooLongSent(false);

	try {
		CommandHandler handler(*this, it);
		handler.manageCommand(message);
	} catch (const std::exception &e) {
		client->sendMessage(e.what(), NULL);
	}
}


// === UPDATE CLIENTS ===

/**
 * @brief Accepts a new client connection to the server.
 *
 * This function handles the acceptance of a new client connection. It performs the following steps:
 * 1. Initializes a sockaddr_in structure to store the client's address.
 * 2. Accepts a new connection and obtains a new socket descriptor for the client.
 * 3. Sets the new client socket to non-blocking mode.
 * 4. Adds the new client to the list of connected clients.
 * 5. Retrieves and stores the client's address.
 * 6. Converts the client's binary address to a readable string format.
 * 7. Sets the client's hostname or defaults to "127.0.0.1" if unavailable.
 * 8. Adds the client's socket descriptor to the set of descriptors monitored for reading.
 * 9. Sets the start of the client's activity.
 * 10. Prompts the client to enter authentication information.
 * 11. Outputs a debug message indicating the client has connected.
 *
 * @note This function uses perror to print error messages if any system call fails.
 */
void Server::_acceptNewClient()
{
	// Structure pour récupérer l'adresse du client qui se connecte
	struct sockaddr_in clientAddr;
	socklen_t clientAddrLen = sizeof(clientAddr);

	// Accepter une connexion et obtenir un nouveau descripteur de socket pour ce client
	int newClientFd = accept(_serverSocketFd, (struct sockaddr*)&clientAddr, &clientAddrLen);
	if (newClientFd < 0)
	{
		perror("Failed to accept new client");
		return;
	}

	// Rendre le nouveau socket non-bloquant
	if (fcntl(newClientFd, F_SETFL, O_NONBLOCK) < 0)
	{
		perror("Failed to set client socket to non-blocking");
		_disconnectClient(newClientFd, CONNECTION_FAILED);
		return;
	}
	_addClient(newClientFd);

	Client* client = _clients[newClientFd];

	// Si l'adresse et le port du client ne sont pas récupérables (ex: proxy, VPN...)
	// on assigne des valeurs par défaut pour éviter une déconnexion
	if (getpeername(newClientFd, (struct sockaddr*)&clientAddr, &clientAddrLen) == -1)
	{
		client->setClientIp(server::UNKNOWN_IP);
		client->setClientPort(0);
	}
	else
	{
		// Buffer pour stocker l'adresse IP du client (NI_MAXHOST garantit une taille suffisante)
		char ipAddr[NI_MAXHOST];
	
		// Convertit l'adresse binaire en chaîne lisible
		if (getnameinfo((struct sockaddr*)&clientAddr, clientAddrLen, ipAddr, sizeof(ipAddr), NULL, 0, NI_NUMERICHOST) != 0)
			client->setClientIp(server::UNKNOWN_IP);
		else
			client->setClientIp(ipAddr);
	
		// Stocke le port source du client (0 si non identifiable)
		int clientPort = ntohs(((struct sockaddr_in*)&clientAddr)->sin_port);
		client->setClientPort(clientPort);
	}

	// Ajouter le descripteur du client à l'ensemble des descripteurs surveillés pour l'écriture et la lecture
	FD_SET(newClientFd, &_readFds);

	// Prompt pour saisir les infos d'authentification
	std::string authenticationPrompt = IrcHelper::commandToSend(*client);
	client->sendMessage(MessageHandler::ircCommandPrompt(authenticationPrompt, "", false), NULL);

	// Log de connexion du client
	std::cout << MessageHandler::msgClientConnected(client->getClientIp(), client->getClientPort(), newClientFd, "") << std::endl;
}

/**
 * @brief Adds a new client to the server.
 *
 * This function creates a new Client object using the provided client file descriptor
 * and adds it to the server's client map.
 *
 * @param clientFd The file descriptor of the client to be added.
 */
void Server::_addClient(int clientFd)
{
	_clients[clientFd] = new Client(clientFd);
}

/**
 * @brief Disconnects a client from the server.
 *
 * This function removes the client's socket from the set of descriptors to monitor,
 * closes the client's socket, and prints a message indicating the successful disconnection.
 *
 * @param fd The file descriptor of the client to disconnect.
 *
 * @return void
 */
void Server::_disconnectClient(int fd, const std::string& reason)
{
	if (reason == SHUTDOWN_REASON || reason == CONNECTION_TIMEOUT || reason == CONNECTION_FAILED)
		_clients[fd]->sendMessage(MessageHandler::ircErrorQuitServer(reason), NULL);

	// Retirer le socket du client des descripteurs à surveiller
	FD_CLR(fd, &_readFds);

	// Fermer le socket du client
	if (close(fd) == -1)
	{
		perror("Failed to close client socket");
		return;
	}

	std::string nick = _clients[fd]->isAuthenticated() ? _clients[fd]->getNickname() : "";
	std::cout << MessageHandler::msgClientDisconnected(_clients[fd]->getClientIp(), _clients[fd]->getClientPort(), fd, nick) << std::endl;
}

/**
 * @brief Deletes a client from the connected clients list.
 *
 * This function removes a client from the map of connected clients and deletes the associated
 * client object. It also closes the client's socket connection.
 *
 * @param it An iterator pointing to the client in the map of connected clients.
 *
 * @return void
 */
void Server::_deleteClient(std::map<int, Client*>::iterator it)
{
	if (it != _clients.end())
	{
		delete it->second; // Supprime l'objet client
		_clients.erase(it->first); // Supprime l'entrée du client dans map
	}
}

/**
 * @brief Deletes clients marked for deletion.
 * 
 * This function iterates through the list of clients that are marked for deletion,
 * deletes each one. After all clients are deleted, the list is cleared.
 */
void Server::_lateClientDeletion()
{
	for (std::vector<std::map<int, Client*>::iterator>::iterator it = _clientsToDelete.begin(); it != _clientsToDelete.end(); ++it)
		_deleteClient(*it);
	_clientsToDelete.clear();
}