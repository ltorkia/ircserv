#include "../../incs/classes/Bot.hpp"

// === OTHER CLASSES ===
#include "../../incs/classes/IrcHelper.hpp"
#include "../../incs/classes/MessageHandler.hpp"

// === NAMESPACES ===
#include "../../incs/config/irc_config.hpp"

// =========================================================================================

// --- PUBLIC
Bot::Bot(int botFd, const std::string& nick, const std::string& user, const std::string& real)
	: _hasSentAuthInfos(false), _isAuthenticated(false), _botFd(botFd),
	_botNick(nick), _botUser(user), _botReal(real), _botMask(_botNick + "!" + '~' + _botUser + "@" + IrcHelper::getEnvValue(env::SERVER_IP_KEY)) {}
Bot::~Bot() {close(_botFd);}


// === SIGNAL ===

/**
 * @brief A static volatile variable to store the signal received status.
 * 
 * This variable is used to indicate whether a signal has been received.
 * It is declared as volatile to prevent the compiler from optimizing
 * out accesses to it, as it may be modified asynchronously by a signal
 * handler.
 */
volatile sig_atomic_t Bot::signalReceived = boolean::FALSE;

/**
 * @brief Signal handler for the server.
 *
 * This function handles the SIGINT and SIGTSTP signals, which are typically
 * generated by pressing Ctrl+C or Ctrl+Z, respectively. When these signals are
 * caught, the server sets signalReceived to true to clean and terminate the program.
 *
 * @param signal The signal number that was caught.
 *
 * @return void
 */
void Bot::signalHandler(int signal)
{
	const char* signalType;

	switch (signal) {
		case SIGINT: signalType = "SIGINT"; break;
		case SIGTSTP: signalType = "SIGTSTP"; break;
		default: signalType = "Unknown";
	}

	std::cout << MessageHandler::msgSignalCaught(signalType) << std::endl;
	signalReceived = boolean::TRUE;
}


// === LISTEN ACTIVITY ===

/**
 * @brief Runs the bot's main loop.
 *
 * This function enters an infinite loop where it continuously checks for a signal.
 * If a signal is received, the loop breaks and the function exits.
 * Otherwise, it handles incoming messages.
 */
void Bot::run()
{
	while (true)
	{
		if (signalReceived)
			break;
		_handleMessage();
	}
}