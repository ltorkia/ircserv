#include "../../incs/classes/Bot.hpp"

// === OTHER CLASSES ===
#include "../../incs/classes/Utils.hpp"
#include "../../incs/classes/IrcHelper.hpp"
#include "../../incs/classes/MessageHandler.hpp"

// === NAMESPACES ===
#include "../../incs/config/irc_config.hpp"
#include "../../incs/config/irc_replies.hpp"
#include "../../incs/config/server_messages.hpp"
#include "../../incs/config/commands.hpp"
#include "../../incs/config/colors.hpp"

using namespace irc_replies;
using namespace server_messages;
using namespace colors;

// =========================================================================================

// --- PUBLIC
Bot::Bot(int botFd, const std::string& nick, const std::string& user, const std::string& real)
	: _hasSentAuthInfos(false), _isAuthenticated(false), _botFd(botFd), _botNick(nick), _botUser(user), _botReal(real),
	_botMask(_botNick + "!" + '~' + _botUser + "@" + IrcHelper::getEnvValue(env::SERVER_IP_KEY)) {}
Bot::~Bot() {}


// === SIGNAL ===

/**
 * @brief A static volatile variable to store the signal received status.
 * 
 * This variable is used to indicate whether a signal has been received.
 * It is declared as volatile to prevent the compiler from optimizing
 * out accesses to it, as it may be modified asynchronously by a signal
 * handler.
 */
volatile sig_atomic_t Bot::signalReceived = boolean::FALSE;

/**
 * @brief Signal handler for the server.
 *
 * This function handles the SIGINT and SIGTSTP signals, which are typically
 * generated by pressing Ctrl+C or Ctrl+Z, respectively. When these signals are
 * caught, the server sets signalReceived to true to clean and terminate the program.
 *
 * @param signal The signal number that was caught.
 *
 * @return void
 */
void Bot::signalHandler(int signal)
{
	const char* signalType;

	switch (signal) {
		case SIGINT: signalType = "SIGINT"; break;
		case SIGTSTP: signalType = "SIGTSTP"; break;
		default: signalType = "Unknown";
	}

	std::cout << MessageHandler::msgSignalCaught(signalType) << std::endl;
	signalReceived = boolean::TRUE;
}

sig_atomic_t Bot::isSignalReceived() const
{
	return signalReceived;
}

// === LISTEN ACTIVITY ===

/**
 * @brief Listens for activity on the server socket and processes incoming messages.
 *
 * This function runs an infinite loop that continuously checks for activity on the server socket.
 * It performs the following steps:
 * 1. If the bot is not authenticated, it attempts to authenticate.
 * 2. Checks if a termination signal has been received from the server and breaks the loop if so.
 * 3. Sets up the file descriptor set and timeout for the select call.
 * 4. Uses the select system call to wait for activity on the server socket.
 * 5. If an error occurs during select (other than an interrupt), it throws a runtime error.
 * 6. If there is activity on the server socket, it reads the input from the server.
 *
 * @throws std::runtime_error If an error occurs during the select system call.
 */
void Bot::listenActivity()
{
	while (true)
	{
		if (isSignalReceived())
			break;
		_readInput();
	}
}


// --- PRIVATE

// === COMMAND HANDLER ===

/**
 * @brief Reads input from the server socket, processes the message, and handles commands.
 *
 * This function reads data from the server socket into a buffer, processes the message by
 * removing any trailing newline and carriage return characters, and then parses and handles
 * the command if the message is valid.
 *
 * @details
 * - Reads data from the server socket using `recv`.
 * - Removes trailing newline and carriage return characters from the message.
 * - Outputs the received message for debugging purposes.
 * - Parses the input message and handles the command if parsing is successful.
 *
 * @note If no data is read from the socket or an error occurs, the function returns immediately.
 */
void Bot::_readInput()
{
	char currentBuffer[server::BUFFER_SIZE];
	std::memset(currentBuffer, 0, sizeof(currentBuffer));

	int bytesRead = recv(_botFd, currentBuffer, sizeof(currentBuffer) - 1, 0);
	if (bytesRead < 0)
	{
		// Erreur de lecture
		perror("Failed to read from client");
		return;
	}
	if (bytesRead == 0)
		throw std::invalid_argument(MSG_CONNECTION_CLOSED);

	currentBuffer[bytesRead] = '\0';

	std::string& bufferMessage = _buffer;
	bufferMessage.append(currentBuffer);

	size_t pos;
	while (((pos = bufferMessage.find('\n')) != std::string::npos))
	{

		// On extrait le message jusqu'au \n (non inclus)
		// + on enlève le \r s'il y en a un (cas irssi)
		// + on supprime la commande traitée du buffer
		std::string message = IrcHelper::extractAndCleanMessage(bufferMessage, pos);

		// Debug : affiche le message reçu
		std::cout << "---> bot received: " << message << std::endl;

		if (_isAuthenticated == false)
		{
			std::string welcomeMsg = MessageHandler::ircWelcomeMessage(_botNick, _botMask);
			if (message == welcomeMsg)
			{
				std::cout << "Welcome message received, bot is authenticated." << std::endl;
				_isAuthenticated = true;
			}
			if (_hasSentAuthInfos == false)
				_authenticate();
			continue;
		}
		if (_noBotCommandFound(message)
			|| _processSpecialMessages(message)
			|| _parsingFailed(message))
			continue;

		std::string response = _handleCommand();
		_sendMessage(MessageHandler::ircMsgBotToClient(_target, response));
	}
}

/**
 * @brief Authenticates the bot with the IRC server.
 *
 * This function performs the authentication process for the bot by sending
 * the necessary IRC commands to the server. It sends the server password,
 * bot nickname, and bot username in sequence, with a delay between each
 * command to ensure proper processing by the server.
 *
 * The function checks if the bot is already authenticated before proceeding
 * with the authentication steps. If the bot is not authenticated, it sends
 * the following commands:
 * - PASS: Sends the server password.
 * - NICK: Sends the bot's nickname.
 * - USER: Sends the bot's username and real name.
 *
 * The function also prints messages to the console to indicate the progress
 * of the authentication process.
 */
void Bot::_authenticate()
{
	std::cout << "\nAuthenticating bot with the server..." << std::endl;

	std::string pass = IrcHelper::getEnvValue(env::PASS_KEY);
	if (pass.empty())
	{
		std::cerr << "Erreur : mot de passe IRC non trouvé dans les variables d'environnement." << std::endl;
		exit(1);
	}

	// connection to irc server
	_sendMessage(commands::PASS + " " + pass);
	std::cout << "\nSending password, waiting for authentication..." << std::endl; 
	sleep(1);

	_sendMessage(commands::NICK + " " + _botNick);
	std::cout << "\nSending nickname, waiting for second authentication..." << std::endl; 
	sleep(1);

	_sendMessage(commands::USER + " " + _botUser + " 0 * :" + _botReal);
	std::cout << "\nSending username, getting bored..." << std::endl; 
	sleep(1);

	_hasSentAuthInfos = true;
}

/**
 * @brief Processes special IRC messages and takes appropriate actions.
 *
 * This function checks if the input message is a special IRC message such as
 * a PING or an error indicating server shutdown. If the message is a PING,
 * it responds with a PONG message. If the message indicates a server shutdown,
 * it throws a runtime error to signal that the connection has been closed.
 *
 * @param input The input message to be processed.
 * @return true if the message was a special message and was processed; 
 *         false otherwise.
 * @throws std::runtime_error if the message indicates a server shutdown.
 */
bool Bot::_processSpecialMessages(const std::string& input)
{
	std::cout << "Processing special messages..." << std::endl;
	if (input == MessageHandler::ircPing())
	{
		_sendMessage(MessageHandler::ircPong());
		return true;
	}
	// if (input == MessageHandler::msgIsInvitedToChannel(_botNick, _clientNickname, _channelName))
	// {
	// 	_sendMessage(MessageHandler::ircJoinChannel(_channelName));
	// 	return true;
	// }
	if (input == MessageHandler::ircErrorQuitServer(SERVER_SHUT_DOWN))
		throw std::runtime_error(MSG_CONNECTION_CLOSED);

	return false;
}

/**
 * @brief Checks if a bot command is found in the input string.
 *
 * This function determines the position of a bot command within the input string
 * using the IrcHelper::getBotCommandStartPos function. If a bot command is found,
 * it returns false. Otherwise, it returns true.
 *
 * @param input The input string to be checked for a bot command.
 * @return true if no bot command is found, false otherwise.
 */
bool Bot::_noBotCommandFound(const std::string& input)
{
	std::cout << "Checking for bot command..." << std::endl;
	size_t commandPos = IrcHelper::getBotCommandStartPos(input);
	if (commandPos != std::string::npos)
		return false;
	return true;
	
}

/**
 * @brief Parses the input string and checks for the validity of the bot command.
 *
 * This function tokenizes the input string and performs several checks to ensure
 * that the input is a valid bot command. It verifies the number of arguments,
 * extracts the command and its arguments, and checks for the presence of a bot
 * command. If any of these checks fail, the function returns true indicating
 * that the input parsing failed.
 *
 * @param input The input string to be parsed.
 * @return true if the input parsing failed, false otherwise.
 */
bool Bot::_parsingFailed(std::string& input)
{
	std::cout << "Parsing input..." << std::endl;
	std::vector<std::string> args = Utils::getTokens(input, splitter::WORD);
	if (args.size() < 4)
		return true;

	Utils::printVector(args);

	// On retourne l'itérateur de la commande et on enregistre
	// dans le même temps le nickname de l'envoyeur.
	// S'il est invalide on retourne args.end().
	std::vector<std::string>::iterator itArg = _getItCommand(args);
	if (itArg == args.end())
		return true;

	// On enregistre le nom du channel si c'est un message channel
	++itArg;
	if (itArg == args.end())
		return true;
	_channelName = *itArg != _botNick ? *itArg : "";

	// On définit la target (le channel ou le client)
	_target = !_channelName.empty() ? _channelName : _clientNickname;

	std::cout << "target : " << _target << std::endl;

	// On recupère l'input du client
	++itArg;
	if (itArg == args.end())
		return true;
	std::string message = Utils::stockVector(itArg, args);

	if (!message.empty() && message[0] == ':')
		message.erase(0, 1);
	if (message.empty())
		return true;

	std::cout << "Message : " << message << std::endl;

	// On vérifie si une commande Bot est présente
	// Si oui on vérifie si elle débute la string ou si elle est précédée d'un espace
	_commandPos = IrcHelper::getBotCommandStartPos(message);
	if (_commandPos == std::string::npos
		|| (message[_commandPos - 1] && !isspace(message[_commandPos - 1])))
		return true;

	// On extrait la commande Bot et ses potentiels arguments
	message = message.substr(_commandPos);

	std::cout << "subst message : " << message << std::endl;
	
	std::vector<std::string> argsInput = Utils::getTokens(message, splitter::SENTENCE);
	if (argsInput.size() < 1)
		return true;

	// On recupère la commande
	std::vector<std::string>::iterator itArgInput = argsInput.begin();
	_command = *itArgInput;
	if (IrcHelper::isInvalidBotCommand(_command))
		return true;

	std::cout << "Commande : " << _command << std::endl;
	
	// On recupère les arguments de la commande s'il y en a
	// Si c'est le cas il s'agit des arguments de la commande !age
	++itArgInput;
	if (_command == bot::AGE_CMD)
	{
		if (itArgInput == argsInput.end())
            return false;
        _ageArg = *itArgInput;
		std::cout << "Arguments : " << _ageArg << std::endl;
	}
	return false;
}

/**
 * @brief Retrieves the iterator pointing to the command in the given arguments.
 *
 * This function processes the provided arguments to extract the nickname of the sender
 * and the command. It first retrieves the nickname and checks if it matches the server's
 * name. If it does, the function returns an iterator to the end of the arguments vector.
 * Next, it retrieves the command and checks if it is either a PRIVMSG or PING command.
 * If the command is not one of these, the function returns an iterator to the end of the
 * arguments vector. Otherwise, it returns an iterator pointing to the command.
 *
 * @param args A reference to a vector of strings containing the arguments.
 * @return An iterator pointing to the command in the arguments vector, or an iterator
 *         to the end of the vector if the nickname matches the server's name or the
 *         command is not PRIVMSG.
 */
std::vector<std::string>::iterator Bot::_getItCommand(std::vector<std::string>& args)
{
	// On recupère le nickname de l'envoyeur
	std::vector<std::string>::iterator itArg = args.begin();
	if (itArg == args.end())
		return args.end();
	_clientNickname = *itArg;

	if (_clientNickname[0] == ':')
		_clientNickname.erase(0, 1);

	if (_clientNickname == server::NAME)
		return args.end();

	std::cout << "Nick : " << _clientNickname << std::endl;

	// On recupère la commande (doit etre PRIVMSG)
	++itArg;
	if (itArg == args.end())
		return args.end();
	std::string command = *itArg;
	if (command != commands::PRIVMSG)
		return args.end();
	return itArg;
}

/**
 * @brief Handles the input command and returns the appropriate response.
 *
 * This function processes the input command and returns a response based on the command type.
 * It supports the following commands:
 * - bot::JOKE_CMD: Returns a joke.
 * - bot::AGE_CMD: Returns the bot's age.
 * - bot::TIME_CMD: Returns the current time.
 * If the command is unknown, it returns an unknown command message.
 *
 * @return A string containing the response to the input command.
 */
std::string Bot::_handleCommand()
{
	if (_command == bot::JOKE_CMD)
		return _getJoke();
	if (_command == bot::AGE_CMD)
		return _getAge();
	if (_command == bot::TIME_CMD)
		return IrcHelper::getTimeString();
	return ERR_UNKNOWNCOMMAND_MSG;
}


// === JOKE COMMAND ===

/**
 * @brief Retrieves a random joke.
 *
 * This function fetches quotes from a predefined path and returns a random quote.
 *
 * @return A random joke as a std::string.
 */
std::string Bot::_getJoke()
{
	_quotes = _getQuotes(bot::QUOTES_PATH);
	return _getRandomQuote();
}

/**
 * @brief Reads quotes from a file and returns them as a vector of strings.
 *
 * This function opens the specified file, reads each line, and stores it in a vector.
 * If the file cannot be opened, it throws an invalid_argument exception.
 *
 * @param filename The path to the file containing the quotes.
 * @return A vector of strings, each representing a quote from the file.
 * @throws std::invalid_argument If the file cannot be opened.
 */
std::vector<std::string> Bot::_getQuotes(std::string filename)
{
	std::vector<std::string> res;
	std::string line;
	std::ifstream file(filename.c_str());

	if (!file.is_open())
		throw std::invalid_argument(ERR_OPEN_FILE);

	while (std::getline(file, line))
		res.push_back(line);
	file.close();

	return res;
}

/**
 * @brief Generates a random quote from the list of quotes.
 * 
 * This function seeds the random number generator with the current time,
 * then selects and returns a random quote from the _quotes vector.
 * 
 * @return A randomly selected quote from the _quotes vector.
 */
std::string Bot::_getRandomQuote()
{
	std::srand(static_cast<unsigned int>(std::time(NULL)));
	return _quotes[std::rand() % _quotes.size()];
}


// === AGE COMMAND ===

/**
 * @brief Retrieves the age of the bot.
 *
 * This function calculates the age of the bot and returns it as a string.
 * If the age cannot be parsed correctly, it sends an error message to the client
 * indicating an invalid date format.
 *
 * @return std::string The calculated age of the bot, or an error message if the date format is invalid.
 */
std::string Bot::_getAge()
{
	std::string res;
	if (_parseAge() == false)
		return INVALID_DATE_FORMAT;

	res = _ageCalculator();
	return res;
}

/**
 * @brief Parses and validates the age argument in the format "YYYY-MM-DD".
 *
 * This function checks if the age argument (_ageArg) is a valid date string
 * in the format "YYYY-MM-DD". It performs the following validations:
 * - The string must be exactly 10 characters long and follow the "YYYY-MM-DD" format.
 * - The year, month, and day components must be numeric.
 * - The year must be between 1900 and the current year.
 * - The month must be between 1 and 12.
 * - The day must be valid for the given month (considering leap years for February).
 * - The date must not be in the future.
 *
 * @return true if the age argument is valid, false otherwise.
 */
bool Bot::_parseAge()
{
	if (_ageArg.empty())
		return false;

	// Vérifier que la chaîne à traiter respecte le format "YYYY-MM-DD"
	if (_ageArg.size() < 10 || _ageArg[4] != '-' || _ageArg[7] != '-' || (_ageArg[11] && !isspace(_ageArg[11])))
		return false;

	// Ne conserver que les 10 premiers caractères
	_ageArg = _ageArg.substr(0, 10);

	// Récupérer la date actuelle
	std::tm now;
	IrcHelper::getCurrentTime(now);

	int currentYear = now.tm_year + 1900;
	int currentMonth = now.tm_mon + 1;

	// Extraire année, mois, jour
	std::istringstream stream(_ageArg);
	std::string yearStr, monthStr, dayStr;

	std::getline(stream, yearStr, '-');
	std::getline(stream, monthStr, '-');
	std::getline(stream, dayStr);

	// Vérifier que tous les caractères sont numériques
	for (size_t i = 0; i < yearStr.size(); ++i)
		if (!std::isdigit(yearStr[i])) return false;
	for (size_t i = 0; i < monthStr.size(); ++i)
		if (!std::isdigit(monthStr[i])) return false;
	for (size_t i = 0; i < dayStr.size(); ++i)
		if (!std::isdigit(dayStr[i])) return false;

	// Convertir en entiers
	int year = std::atoi(yearStr.c_str());
	int month = std::atoi(monthStr.c_str());
	int day = std::atoi(dayStr.c_str());

	// Vérification de l'année
	if (year < 1900 || year > currentYear)
		return false;

	// Vérification du mois
	if (month < 1 || month > 12)
		return false;

	// Vérification du jour
	if (day < 1 || day > 31)
		return false;

	// Vérifier les mois à 30 jours
	if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)
		return false;

	// Vérifier février (année bissextile)
	bool isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
	if (month == 2)
	{
		if (isLeapYear && day > 29)
			return false;
		else if (!isLeapYear && day > 28)
			return false;
	}

	// Vérification que la date n'est pas dans le futur
	if (year == currentYear && month > currentMonth)
		return false;

	return true;
}

/**
 * @brief Calculates the age based on the provided birth date.
 *
 * This function calculates the age in years, months, and days from the birth date
 * provided in the _ageArg member variable. The birth date should be in the format "YYYY-MM-DD".
 *
 * @return A string representing the age in a specific format, as returned by MessageHandler::botGetAge.
 */
std::string Bot::_ageCalculator()
{
	int year, month, day;
	year = std::atoi(_ageArg.substr(0, 4).c_str());
	month = std::atoi(_ageArg.substr(5, 2).c_str());
	day = std::atoi(_ageArg.substr(8, 2).c_str());

	// Obtenir la date actuelle
	std::tm now;
	IrcHelper::getCurrentTime(now);

	// Calcul de l'âge en années
	int years = now.tm_year + 1900 - year;
	int months = now.tm_mon + 1 - month;
	int days = now.tm_mday - day;

	// Ajustement si l'anniversaire n'est pas encore passé cette année
	if (months < 0 || (months == 0 && days < 0))
	{
		years--;
		months += 12;
	}
	if (days < 0)
	{
		// Trouver le nombre de jours dans le mois précédent
		static const int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
		int prevMonth = (month == 1) ? 12 : month - 1;
		int prevYear = (month == 1) ? year - 1 : year;

		// Vérifier année bissextile pour février
		int daysInPrevMonth = daysInMonth[prevMonth - 1];
		if (prevMonth == 2 && ((prevYear % 4 == 0 && prevYear % 100 != 0) || (prevYear % 400 == 0)))
			daysInPrevMonth = 29;

		days += daysInPrevMonth;
		months--;
	}
	return MessageHandler::botGetAge(years, months, days);
}

// === SEND MESSAGES ===

/**
 * @brief Sends a message from the bot to the IRC server.
 *
 * This function formats the given message according to IRC protocol
 * (adds \r\n and truncates to 512 characters if too long) and sends it
 * through the bot's file descriptor. It also logs the sent message to
 * the standard output.
 *
 * @param message The message to be sent.
 */
void Bot::_sendMessage(const std::string &message) const
{

	// On formate le message en IRC (ajout du \r\n, si trop long tronqué à 512 caractères)
	std::string formattedMessage = MessageHandler::ircFormat(message);

	std::cout << "<--- bot sent: " << formattedMessage << std::endl;

	if (send(_botFd, formattedMessage.c_str(), formattedMessage.length(), MSG_NOSIGNAL) == -1)
		perror("send() failed");
}